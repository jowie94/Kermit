grammar Kermit;

options {
	language=CSharp3;
	TokenLabelType=CommonToken;
	output=AST;
	ASTLabelType=KermitAST;
}

tokens {
	BLOCK; ARGS; CALL; FUNC='function';
	ASSIGN='='; ADD='+'; SUB='-'; MUL='*'; DIV='/';
}

@lexer::namespace{Parser}
@parser::namespace{Parser}

@members {
	IScope currentScope;
	public KermitParser(ITokenStream input, IScope globalScope) : this(input)
	{
		currentScope = globalScope;
	}
}

/*
 * Parser Rules
 */

public
program
	: (functionDefinition|statement)+ EOF
	  -> ^(BLOCK statement+)
	;

functionDefinition
	: 'function' ID
	 {
		FunctionSymbol fs = new FunctionSymbol($ID.text, currentScope);
		currentScope.Define(fs);
		currentScope = fs;
	 }
	 '(' (vardef (',' vardef)* )? ')'
	 {currentScope = new LocalScope(fs);}
	 slist
	 {
		fs.BlockAST = $slist.tree;
		currentScope = currentScope.EnclosingScope;
		currentScope = currentScope.EnclosingScope;
	 }
	 ->
	;

vardef
	: ID
	 {
		$ID.tree.Scope = currentScope;
		VariableSymbol vs = new VariableSymbol($ID.text);
		currentScope.Define(vs);
	 }
	;

slist
	: NL* '{' statement* '}' NL*	-> ^(BLOCK statement*)
	| statement						-> ^(BLOCK statement)
	;

statement
	: qid '=' expr NL	-> ^('=' qid expr)
	| call NL			-> call
	| NL				->
	;

call
@after {
	$call.tree.Scope = currentScope;
}
	: name=ID '(' (expr (',' expr)*)? ')' -> ^(CALL ID expr*) ;

expr: addexpr ;

addexpr
	: mulexpr (('+'|'-')^ mulexpr)*
	;

mulexpr
	: atom (('*'|'/')^ atom)*
	;

atom
	: INT
	| CHAR
	| FLOAT
	| STRING
	| qid
	| call
	| '(' expr ')' -> expr
	;

qid : ID; // Can't be resolved until runtime


/*
 * Lexer Rules
 */

WS	:   (' '|'\t') {$channel=Hidden;};

NL	:	'\r'? '\n' ;

ID  :   LETTER (LETTER | '0'..'9')*  ;

fragment
LETTER
	:   ('a'..'z' | 'A'..'Z')
	;

CHAR:	'\'' . '\'' ;

STRING:	'\"' .* '\"' ;

INT :   '0'..'9'+ ;

FLOAT
	:	INT '.' INT*
	|	'.' INT+
	;

SL_COMMENT
	:   '//' ~('\r'|'\n')* {$channel=Hidden;}
	|	'/*' ('\w'|'\W')* '*/' {$channel=Hidden;}
	;
