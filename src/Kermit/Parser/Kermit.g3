grammar Kermit;

options {
	language=CSharp3;
	TokenLabelType=CommonToken;
	output=AST;
	ASTLabelType=KermitAST;
}

tokens {
	BLOCK; ARGS; CALL; DOT='.'; REF='ref';
	FUNC='function'; RETURN='return'; IF='if'; WHILE='while'; FOR='for'; NEW='new'; // Keywords
	EQ='=='; LT='<'; BT='>'; LTE='<='; BTE='>='; NE='!='; TRUE='true'; FALSE='false'; // Logical (TODO: Add more logical tokens)
	NUM; ASSIGN='='; ADD='+'; SUB='-'; MUL='*'; DIV='/'; // Arithmetics
}

@lexer::namespace{Kermit.Parser}
@parser::namespace{Kermit.Parser}

@members {
	IScope currentScope;
	public KermitParser(ITokenStream input, IScope globalScope) : this(input)
	{
		currentScope = globalScope;
	}
}

/*
 * Parser Rules
 */

public
program
	: (functionDefinition|statementOrNL)+ EOF
	  -> ^(BLOCK statementOrNL*)
	;

functionDefinition
	: 'function' ID
	 {
		FunctionSymbol fs = new FunctionSymbol($ID.text, currentScope);
		currentScope.Define(fs);
		currentScope = fs;
	 }
	 '(' (vardef (',' vardef)* )? ')'
	 {currentScope = new LocalScope(fs);}
	 multipleStatements
	 {
		fs.BlockAST = $multipleStatements.tree;
		currentScope = currentScope.EnclosingScope;
		currentScope = currentScope.EnclosingScope;
	 }
	 ->
	;

vardef
	: ID
	 {
		$ID.tree.Scope = currentScope;
		VariableSymbol vs = new VariableSymbol($ID.text);
		currentScope.Define(vs);
	 }
	;

soms // Single or multiple statements
	: NL* statement	-> ^(BLOCK statement)
	| multipleStatements
	;

multipleStatements
	: NL* '{' statementOrNL* '}' NL	-> ^(BLOCK statementOrNL*)
	;

statementOrNL // Extended statements (include newline)
	: statement
	| NL		->
	;

statement // Normal statements
	: equalOrCall NL		-> equalOrCall
	| 'return' expr NL		-> ^('return' expr)
	| 'if' '(' expr ')' c=soms ('else' el=soms)?			-> ^('if' expr $c $el?)
	| 'while' '(' expr ')' soms								-> ^('while' expr soms)
	| 'for' '(' beg=equalOrCall ';' cond=expr ';' wh=equalOrCall ')' soms	-> ^('for' $beg $cond $wh soms)
	;

equalOrCall
	: qid '=' expr	-> ^('=' qid expr)
	| call
	;

call
@after {
	$call.tree.Scope = currentScope;
}
	: name=ID '(' (refOrExpr (',' refOrExpr)*)? ')' -> ^(CALL ID refOrExpr*) ;

refOrExpr
	: 'ref' qid	-> ^('ref' qid)
	| expr
	;

expr: addexpr (('=='|'!='|'<'|'>'|'<='|'>=')^ addexpr)? ;

addexpr
	: mulexpr (('+'|'-')^ mulexpr)*
	;

mulexpr
	: notOrAtom (('*'|'/')^ notOrAtom)*
	;

notOrAtom
	: NOT notOrAtom -> ^(NOT notOrAtom)
	| qatom
	;

qatom
	: atom ('.'^ (ID|call))*;

atom
	: '-'? n=(INT|FLOAT) -> ^(NUM $n '-'?)
	| CHAR
	| STRING
	| ('true'|'false')
	| ID
	| call
	| instance
	| '(' expr ')' -> expr
	;

instance
@after {
	KermitAST nameNode = (KermitAST) $instance.tree.GetChild(0);
	nameNode.Scope = currentScope;
}
	:	'new' ID '(' (expr (',' expr )*)? ')' // TODO: Future improvement, support subclasses
		-> ^('new' ID expr*)
	;

qid :  ID ('.'^ ID)* ; // Can't be resolved until runtime


/*
 * Lexer Rules
 */

WS		:   (' '|'\t') {$channel=Hidden;};

NL		:	'\r'? '\n' ;

ID		:   LETTER (LETTER | '0'..'9' | '-' | '_')*  ;

fragment
LETTER
	:   ('a'..'z' | 'A'..'Z')
	;

CHAR	:	'\'' . '\'' ;

STRING	:	'\"' .* '\"' ;

AND		:	('and' | '&&') ;

OR		:	('or' | '||') ;

NOT		:	('not' | '!') ;

INT		:	'0'..'9'+ ;

FLOAT
	:	INT '.' INT*
	|	'.' INT+
	;

SL_COMMENT
	:   '//' ~('\r'|'\n')* {$channel=Hidden;}
	|	'/*' ('\w'|'\W')* '*/' {$channel=Hidden;}
	;
